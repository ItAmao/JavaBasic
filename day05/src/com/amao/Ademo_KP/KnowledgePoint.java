package com.amao.Ademo_KP;

public class KnowledgePoint {
    public static void main(String[] args) {
        /*
            多态的前提是有一个父类，多个子类。
            多态:是继封装、继承之后,面向对象的第三大特征

            定义:多态:是指同一行为,对于不同的对象具有多个不同的表现形式
            程序中的多态,是指同一方法,对不同的对象具有不同的实现

            前提条件
                1.继承或者实现(二选一)
                2.父类的引用指向之类的对象(格式体现)
                3.方法的重写(意义体现:不重写,无意义)

        多态时访问成员的特点:
            成员变量:   编译去父类中找,如果找到就编译成功,否则编译失败(编译看父类,执行也看父类)
            成员方法:
                      非静态方法:    编译看父类,如果有编译通过,如果没有编译失败  运行看子类(编译看左边,运行看右边)
                      静态方法       编译看父类,如果有编译通过,如果没有编译失败, 运行看父类(编译看左边,运行看左边)

            记忆:只要非静态方法编译看父类,运行看子类,其余都是看父类
            注意:多态情况下,无法访问子类独有的成员方法/成员变量

         如果方法的参数类型为父类类型,那么就可以接收父类类型的对象或者子类类型的对象,提高程序的扩展性
        如果方法的返回值类型为父类类型,那么就可以返回该父类类型的对象或者子类对象
        多态的应用场景
            变量多态  ------->场景不多
            参数多态  ------->常见
            返回值多态 ------->常见



        多态的好处和弊端
                好处:
                    父类类型作为方法形式参数,传递子类对象给方法,进行方法的调用,更能体现出多态的扩展性与便利
                    父类类型作为方法返回值类型,返回子类对象,进行方法的调用,更能体现出多态的扩展性与便利
                弊端:
                    多态的情况下,只能调用父类的共性内容,不能调用子类的特有内容.


       向上转型:   子类类型向父类类型转换的过程,这个过程是自动的 格式: 父类类型 变量名=new 子类();
            向下转型:   父类类型向子类类型转换的过程,这个过程是强制的 格式: 子类类型 变量名=(子类类型)new 父类类型的对象/变量;

            注意事项:
                    如果需要转型的父类类型变量指向的不是要转换的子类类型对象,那么就会报类型转换异常
                    解决: 使用instanceof关键字进行类型判断
                    格式:
                        if(变量名 instanceof 数据类型){}
                        如果左边的变量名指向的对象是属于后边的数据类型,那么返回true,否则放回flase
---------------------------------------------------------------------------------------------------------

        内部类:
            概述:将一个类A定义在一个类B中,其中类A就是内部类
            成员内部类:
                格式:
                  public class 外部类{
                        成员变量
                        成员方法

                        public class 内部类{
                            成员变量
                            成员方法
                        }
                  }
        特点:   1成员内部类是定义在类中,方法外
               2访问规则:
                  1在内部类中可以访问一切外部类成员,包括私有的
                  2内部类在其他类中创建对象的格式:
                     外部类名.内部类名 对象名=new 外部类().new 内部类();
                  3.在外部类中访问内部类的成员,需要创建内部类对象


        匿名内部类的概述
                   匿名内部类:其实就是一个类的匿名子类对象

                概述:
                    1.本质其实就是一个继承了类的匿名子类的对象
                    2.本质其实是一个实现了接口的匿名实现类的对象

                匿名内部类格式:
                        父类 对象名=new 父类类型 (){
                            实现抽象方法
                        };
                        接口 对象名=new 接口类型(){
                            实现抽象方法
                        };


                匿名内部类的作用:没有特殊的功能,只是用来简化代码的;

-----------------------------------------------------------------------------------------------
        概述:
                在java中提供了四种访问权限,使用不同的访问权限修饰符时,被修饰的内容会有不同的访问权限

            public :    公共的
            protected:  受保护的
            (空的)       默认的
            private:    私有的

            * 权限修饰符
            * 1. 外部类: public, （default）
            * 2. 成员内部类: public, protected, (default), private
            * 3. 局部内部类: 什么都不写(但这儿并不等同于default的含义)
              4. 成员变量使用 private
              5. 构造方法使用 public
              6. 成员方法使用 public

            不用的访问权限的访问能力
                            本类       同一个包      不同包父子类       不同包的无关类
            public          yes         yse           yes              yes
            protected       yes         yes           yes              no
            default         yes         yes           no               no
            private         yes         no            no               no

            访问权限的大小关系   public > protected > default > private

--------------------------------------------------------------------------------------------------
代码块:
                格式:{}
                位置:         类中方法外
                执行:         每次调用构造方法就会执行
                使用场景       一般用来统计多少个对象被创建了



            静态代码块:
                    格式: static {}
                    位子: 类中方法外
                    执行: 类加载的时候执行,并且只执行一次
            局部代码块:
                格式:{}
                位置:方法中
                执行:调用局部代码块所在的方法,执行到局部代码块的时候才执行
                使用场景:节省内存空间,实际上没啥用

            静态代码块优先于构造代码块执行,构造代码块优先于构造方法执行

     */

    }
}
