package com.amao.Ademo_KP;

public class Test {
    public static void main(String[] args) {
        /**
         * 1.List接口
         *       特点:
         *          1.有序的(Java中的有序不是指123这种自然顺序,它是指存入元素的顺序和打印集合时顺序是一致的)
         *          2.有索引
         *          3.元素可以重复
         *
         * 2.List接口中常用的方法以及它的子类
         *      List接口常用方法(Collection根接口中继承的7个之外):
         *          增:  add(int index,E e)
         *          删:  remove(int index)
         *          改:  set(int index,E e)
         *          查:  get(int index)
         *
         *      List的常见实现类有哪些?
         *          ArrayList实现类
         *          LinkedList实现类
         *          Vector实现类
         *
         * 3.ArrayList数据结构以及使用
         *      ArrayList集合底层的数据结构:数组结构(查改快,增删慢)
         *      ArrayList集合有哪些方法:
         *          1. 7个Collection接口中
         *          2. 4个List接口中
         *          3. 没有特有方法
         *
         * 4.LinkedList的数据结构以及使用
         *      LinkedList集合底层的数据结构:链表结构(查改慢,增删快)
         *      LinkedList集合有哪些方法:
         *          1.7个Collection接口中
         *          2.4个List接口
         *          3.8个特有方法:
         *              public void addFirst(E e) :将指定元素插入此列表的开头。
         *              public void addLast(E e) :将指定元素添加到此列表的结尾。
         *              public E getFirst() :返回此列表的第一个元素。
         *              public E getLast() :返回此列表的最后一个元素。
         *              public E removeFirst() :移除并返回此列表的第一个元素。
         *              public E removeLast() :移除并返回此列表的最后一个元素。
         *              public E pop() :从此列表所表示的堆栈处弹出一个元素。
         *              public void push(E e) :将元素推入此列表所表示的堆栈。
         *              public boolean isEmpty() :如果列表不包含元素，则返回true。
         *
         *------------------------------------------------------------------------------------------
         * Collections类
         *      1.Collections的介绍
         *          Collections是一个集合工具类,其中方法都是静态的(可以通过类名直接调用)
         *
         *      2.Collections常用功能
         *          public static <T> void sort(List<T> list);对集合的元素进行升序排序
         *          public static void shuffle(List<?> list);对集合的元素进行随机打乱
         *
         * -------------------------------------------------------------------------------------------
         *Comparator比较器排序
         *     1.Comparator比较器排序
         *          public static <T> void sort(List<T> list,Comparator com);比较器排序
         *
         *--------------------------------------------------------------------------------------------
         * 可变参数
         *      1.格式:
         * 	          public void 方法名(数据类型... 参数名){}
         *
         *      2.作用:
         * 	          表达该方法参数个数可以任意(参数类型必须是指定的数据类型)
         *
         * 	    3.本质:
         * 	          可变本质其实是一个数组
         *
         *      4.限制:
         * 	          a.一个方法中只能有一个可变参数
         *            b.一个方法中既有可变参数,又有普通参数,这是允许,但是可变参数必须写到最后
         *
         *------------------------------------------------------------------------------------------
         * Set接口
         *      1.特点:
         *          a.无序的(无序在Java是指存入时元素的顺序和打印集合时元素的顺序不能保证一致)(LinkedHashSet除外)
         *          b.无索引
         *          c.元素唯一的
         *          注意:
         *      	    Set接口有一个实现类不是无序的,是有序的,LinkedHashSet
         *
         *      2.Set接口的常用方法以及常用子类
         *          7个Collection中定义的方法
         *          特有方法:没有
         *
         *      3.Set接口的实现类
         *          HashSet :       无序的,无索引,不可重复
         *          LinkedHashSet   有序的,无索引,不可重复
         *          TreeSet         无序的(有自然顺序的),无索引,不可重复的
         *
         *---------------------------------------------------------------------------------------------
         * HashSet的数据结构以及使用
         *      1.HashSet的底层数据结构:哈希表结构(数组+链表+红黑树<JDK8中新增>)
         *
         *      2.HashSet中定义的方法
         *          7个Collection中定义的方法
         *          0个Set中定义的方法
         *          0个特有方法
         *
         *     3.HashSet的特定:
         * 	        无序的,无索引,元素唯一的
         *
         *     4.HashSet注意事项:
         *          由于我们所创建的HashSet是Integer类型的，这也是最巧的一点，
         *          Integer类型hashCode()的返回值就是其int值本身，
         *          而存储的时候元素通过一些运算后会得出自己在数组中所处的位置。
         *          由于在这一步，其本身即下标(只考虑这一步)，其实已经实现了排序功能，
         *          由于int类型范围太广，内存放不下，所以对其进行取模运算，为了减少哈希冲突，
         *          又在取模前进行了，扰动函数的计算，得到的数作为元素下标，按照JDK8下的hash算法，
         *          以及load factor及扩容机制，这就导致数据在经过 HashMap.hash()运算后仍然是自己本身的值，
         *          且没有发生哈希冲突。
         *
         *-----------------------------------------------------------------------------------------------
         * LinkedHashSet的数据结构以及使用
         *      1.LinkedHashSet的底层数据结构: 链表+哈希表结构
         *
         *      2.LinkedHashSet的常见方法:
         * 		        7个Collection中定义的方法
         *     	        0个Set中定义的方法
         *     	        0个特有方法
         *
         *     3.LinkedHashSet的特点:
         * 	        有序的!!!!!! 无索引,元素唯一的
         *
         * ---------------------------------------------------------------------------------------------
         *TreeSet的数据结构以及使用
         *      1.TreeSet的底层数据结构: 红黑树结构(查询效率的非常恐怖的)
         *
         *      2.TreeSet的常见方法:
         * 		        7个Collection中定义的方法
         *     	        0个Set中定义的方法
         *     	        0个特有方法
         *
         *     3.TreeSet的特点:
         * 		       无序的(默认升序的),无索引,元素唯一的
         *
         * ----------------------------------------------------------------------------------------------
         * 哈希表结构的介绍[扩展]
         *      1.对象的哈希值(对象的"数字指纹")
         *          a.如何查看对象的哈希值呢??
         *                  非常简单,调用对象的hashCode方法,即可得到该对象的哈希值
         *          b.其实我们以前说的地址值都是假的,它其实是哈希值的16进制而已
         *               public String toString() {
         *                      //从以下代码就可以看出,我们看到地址值,其实是根据获取到hash值转成后的16进制表示
         *                      return getClass().getName() + "@" + Integer.toHexString(hashCode());
         *                  }
         *
         *  	        public native int hashCode();
         *  	                        哈希值的计算不是Java写的,是c/c++写的,
         * 								底层通过哈希算法计算出的,所有这个值哈希值
         *          c.在Java中有没有真正的地址值呢??
         *                  有! 对象名中保存的其实就是真正的地址值
         *                  例如: Dog d1 = new Dog(2,"jack"); d1中保存的其实就是真正的地址值
         *                  但是无法打印出来:
         * 		            System.out.println(d1); ==> System.out.println(d1.toString());
         *          d.hashCode方法我们能否重写??
         *                  必须可以,重写后不管hashCode和还是toString都会调用重写后的hashCode方法
         *
         *      2.==结论:哈希表结构如何保证元素的唯一性?==
         *              非常简单: 先比较两个对象的哈希值,如果哈希值一样,再调用equals方法,
         * 			            只有哈希值一样且equals方法返回值是true,才判定这两个元素重复
         *
         *      3.哈希表通过哈希值和equals双重标准,判断元素是否重复
         *          所有当我们使用哈希值结构的集合来保存自定义类型时,需要在自定义类中重写hashCOde和equals方法,
         *          以保证哈希表的唯一性!!
         *
         *---------------------------------------------------------------------------------------------
         *
         *
         */
    }
}

