package com.amao.Ademo_KP;

public class Test {
    /**
     * 线程池
     *      1.线程池的思想
     *          线程池的基本思想还是一种对象池的思想，开辟一块内存空间，里面存放了众多(未死亡)的线程，
     *          池中线程执行调度由池管理器来处理。当有线程任务时，从池中取一个，执行完成后线程对象归池，
     *          这样可以避免反复创建线程对象所带来的性能开销，节省了系统的资源。
     *
     *      2.线程池的概念
     *          其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象
     *          的操作，无需反复创建线程而消耗过多资源。
     *
     *      3.线程池的好处
     *          1. 降低资源消耗。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。
     *          2. 提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。
     *          3. 提高线程的可管理性。可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗
     *             过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。
     *
     *      4.线程池的使用
     *          1.Java里面线程池的顶级接口是 java.util.concurrent.Executor 执行器
     *          2.线程池的子接口:java.util.concurrent.ExecutorService
     *          3.线程池的工具类: java.util.concurrent.Executors   其中有一个静态方法,用于创建线程池的实现类对象
     *          //创建一个具有指定线程数量的线程池对象 nThreads:线程数量
     *          public static ExecutorService newFixedThreadPool(int nThreads) :返回线程池对象。(创建的是有界线程池,也就是池中的线程个数可以指定最大数量)
     *
     *          4.ExecutorService线程池接口中定义了一个提交任务的方法:
     *              //向当前的线程池中提交某个任务
     *              public Future<?> submit(Runnable task) :获取线程池中的某一个线程对象，并执行
     *              public Future<?> submit(Callable<T> task) :向当前的线程池中提交某个任务
     *
     *          5使用线程池中线程对象的步骤:
     *              1. 创建线程池对象。
     *              2. 创建Runnable接口子类对象。(task)
     *              3. 提交Runnable接口子类对象。(take task)
     *              4. 关闭线程池(一般不做)。
     *
     *---------------------------------------------------------------------------------------------------------------
     *  死锁
     *      1.什么是死锁
     *          不同的线程分别占用对方需要的同步资源不放弃,都在等待对方放弃自己需要的同步资源,就形成了线程的死锁
     *          出现死锁后,不会出现异常,不会出现提示,知识所有的线程都处于阻塞状态,无法继续
     *
     *          在多线程程序中,使用了多把锁,造成线程之间相互等待.程序不往下走了。
     *
     *      2.产生死锁的条件
     *          1.至少有两个线程
     *          2.至少有两个对象
     *          3.需要嵌套获取锁对象
     *
     *      3.解决方法
     *          1.专门的算法,原则
     *          2.尽量减少同步资源的定义
     *          3.尽量避免嵌套同步
     *
     *---------------------------------------------------------------------------------------------------------------
     *  线程状态(生命周期)
     *      1.NEW(新建)新建态:刚刚创建且未启动的状态
     *          导致状态发生条件:
     *              线程刚被创建，但是并未启动。还没调用start方法。MyThread t = new MyThread只有线程对象，没有线程特征。
     *
     *      2.Runnable(可运行)就绪态:可运行状态(就绪/可运行)
     *          导致状态发生条件:
     *             线程可以在java虚拟机中运行的状态，可能正在运行自己代码，也可能没有,这取决于操作系统处理器。
     *             调用了t.start()方法
     *
     *      3.Teminated(被终止)死亡态:已退出/消亡状态
     *          导致状态发生条件:
     *              因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。
     *
     *      4.Blocked(锁阻塞)阻塞态:
     *          导致状态发生条件
     *              当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，
     *              则该线程进入Blocked状态;当该线程持有锁时，该线程将变成Runnable状态。
     *
     *      5.Timed Waiting(计时 等待)等待态:限时等待/休眠状态
     *          导致状态发生条件
     *              同waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。
     *              这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常 用方法有Thread.sleep 、Object.wait。
     *
     *      6.Waiting(无限等待):永久等待
     *          1.拿到锁对象 2.调用锁对象的wait方法  3.当前会自动释放锁对象,然后进入永久等待
     *
     *          导致状态发生条件
     *              一个线程在等待另一个线程执行一个(唤醒)动作时，该线程进入Waiting状 态。进入这个状态后是不能自动唤醒的，
     *              必须等待另一个线程调用notify或者 notifyAll方法才能够唤醒。
     *
     *---------------------------------------------------------------------------------------------------------------
     *  等待唤醒机制
     *
     *---------------------------------------------------------------------------------------------------------------
     * 定时器
     *      1.什么是定时器?
     *          我们可以想象成闹钟,在指定时间做指定的事情
     *          定时器，可以设置线程在某个时间执行某件事情，或者某个时间开始，每间隔指定的时间反复的做某件事情
     *
     *      2.定时器的使用?
     *          构造方法:
     *                  public Timer() 构造一个定时器
     *          成员方法:
     *                  public void schedule(TimerTask task,Date time):在指定的时候安排指定的任务执行
     *                  public void schedule(TimerTask task,long millis); 在指定的延迟之后安排指定的任务执行
     *                  public void schedule(TimerTask task,Date time,long period0;在指定的时间开始,对指定的任务执行重复
     *                                                                              固定的延迟
     *                  public void schedule(TimerTask task,long millis,long period);在指定的延迟之后开始,重新执行固定延迟执行
     *                                                                              的指定任务
     *
     *---------------------------------------------------------------------------------------------------------------
     *  补充:
     *      新增创建线程方式二:
     *          1.好处
     *              提高了响应速度(减少了创建新线程的时间)
     *              降低资源消耗(重复利用线程池中线程,不需要每次都创建)
     *              便于线程管理
     *
     *          2.线程池相关API
     *              JDK5.0起提供了线程池相关API:ExecutorService和Executors
     *              ExecutorService:真正的线程池接口,常见子类ThreadPoolExecutor
     *              Executors:工具类,线程池的工厂类,用于创建并返回不同类型的线程池
     *
     *          3.
     *
     *
     *
     */
    public static void main(String[] args) {

    }
}
