package com.amao.Ademo_KP;

import java.util.Map;
import java.util.Set;

/**
 * @description:
 * @params:
 * @return:
 * @author: ItAmao
 * @time: 2020/6/18 09:28
 */
public class Test {
    public static void main(String[] args) {
        /**
         *  多线程
         *      单核CPU:其实是一种假的多线程,因为在一个世界单元内,也只能执行一个线程的任务
         *
         *      1.并行和并发
         *          并行:两个事件在同一时刻都在执行(同时执行) 多个CPU同时执行多个任务
         *          并发:两个事件在同一时间段内都在执行,但在某个时刻只有一个在执行(交替执行),一个CPU同时执行多个任务
         *
         *      2.进程和线程
         *          程序:是为了完成特定任务,用某种语言编写的一组指令的集合,即指一段静态代码,静态对象
         *          进程:正在内存中运行的程序,称为进程(每一个进程执行都有一个执行顺序，该顺序是一个执行路径，或者叫一个控制单元。)
         *          是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，
         *          一个应用程序可以同时运行多个进程;进程也是程序的一次执行过程，
         *          是系统运行程序的基本单位;系统运行一个程序 即是一个进程从创建、运行到消亡的过程。
         *
         *          线程:一个进程中用来完成某个任务的执行单元
         *          是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。
         *          一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。
         *          一个进程中可以有一个到多个线程,如果有一个以上的线程,这种进程我们一般称为多线程
         *
         *      3.进程和线程的区别
         *          进程:有独立的内存空间，进程中的数据存放空间(堆空间和栈空间)是独立的，至少有一个线程。
         *          线程:堆空间是共享的，栈空间是独立的，线程消耗的资源比进程小的多。
         *
         *          1:因为一个进程中的多个线程是并发运行的，那么从微观角度看也是有先后顺序的，哪个线程执
         *              行完全取决于CPU的调度，程序员是干涉不了的。而这也就造成的多线程的随机性。
         *          2:Java 程序的进程里面至少包含两个线程，主进程也就是 main()方法线程，另外一个是垃圾回收 机制线程。
         *              每当使用 java 命令执行一个类时，实际上都会启动一个JVM，每一个 JVM 实际上就 是在操作系统中启动了一个线程，
         *              java 本身具备了垃圾的收集机制，所以在 Java运行时至少会启 动两个线程。
         *          3:由于创建一个线程的开销比创建一个进程的开销小的多，那么我们在开发多任务运行的时候，
         *              通常考虑创建多线程，而不是创建多进程。
         *
         *      使用多线程的优点
         *          1.提高应用程序的响应,对图形化界面更有意义,可增强用户体验
         *          2.提高计算机系统CPU的利用率
         *          3.改善程序结构,将即长又复杂的进程分为多个线程,独立运行,利于理解和修改
         *
         *      何时需要多线程
         *          1.程序需要同时执行两个或多个任务
         *          2.程序需要实现一些需要等待的任务时,如用户输入,文件读写操作,网络操作,搜索等
         *          3.需要一些后台运行的程序时
         *      4.什么是线程的调度
         *          就是指CPU在多个线程之间进行快速的切换
         *
         *          线程的优先级等级
         *              MAX_PRIORITY:10;    最大的优先级是10
         *              MIN_PRIORITY:1;     最小的优先级是1
         *              NORM_PRIORITY:5;    默认的优先级是5
         *          涉及方法
         *              getPriority() 返回线程优先值
         *              setPriority(int newPriority) 改变线程的优先级
         *
         *          分时调度
         *              所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。
         *          抢占式调度
         *              优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，
         *              Java使用的为抢占式调度。
         *
         *      5.jvm多线程的启动是多线程吗？
         * 	        java的虚拟机jvm启动的是单线程的话，就有发生内存泄露的可能，而我们使用java程序没出现这样的问题，
         * 	        也就是jvm启动至少有两个线程，一个执行java程序，一个执行垃圾回收。所以是多线程。
         *
         *      2、多线程的优势：
         * 	            解决了多部分同时运行的问题，提高效率
         *
         *      3、线程的弊端：
         * 	            线程太多会导致效率的降低，因为线程的执行依靠的是CPU的来回切换。
         *
         *      4、什么叫多线程：
         * 	            一个进程中有多个线程，称为多线程。
         *
         *------------------------------------------------------------------------------------------
         *  Thread类介绍
         *      1.Thread类是什么?
         *          它是Java中代表线程的类,创建一个该类对象就相当于创建了一个新的线程
         *
         *      2.Thread类的构造方法
         *          public Thread(); 创建一个新的线程对象,默认线程名Thread-0,Thread-1,....
         *          public Thread(String name);创建一个新的线程对象并指定线程的名字
         *          public Thread(Runnable target);创建一个新的线程对象并指定该线程的任务
         *          public Thread(Runnable target,String name);创建一个新的线程对象并指定该线程的任务和线程的名字
         *
         *      3.Thread类的常用方法
         *          static void yield() 线程让步
         *                  1.暂停当前正在执行的线程,把执行机会让给优先级相同或更高的线程
         *                  2.若队列中没有同优先级的线程,忽略此方法
         *          join():当某个线程执行流中调用其他线程的join()方法时,调用线程将被阻塞,直到join()方法加入join线程执行完为止
         *          stop():强制线程生命周期结束,不推荐使用
         *          boolean isAlive(): 放回boolean,判断线程是否还活着
         *          public void setName(String name);修改线程的名字
         *          public String getName();获取线程名字
         *          public void start();开启线程(线程只创建是不会执行的,必须开启后才会执行)
         *          public void run();这方法是线程的任务方法,我们要把线程需要执行的代码写到该方法中
         *          public static void sleep(long millis);让当前线程"休眠"millis毫秒
         *                                                这里的"当前线程"是指: Thread.sleep(1000)这句代码所在的线程
         *          public static Thread currentThread();获取当前线程对象
         *                                               这里的"当前线程"是指: Thread.currentThread()这句代码所在的线程
         *
         *      4.创建新的线程方式一_继承方式
         *          API描述:
         * 	                第一种方式是:
         * 		                        将类声明为 Thread 的子类。
         *                              该子类应重写 Thread 类的 run 方法。
         *                              接下来可以分配并启动该子类的实例
         *          翻译步骤:
         * 	                a.创建一个子类继承Thread
         *                  b.子类中重写run方法(在run方法中写你这个线程要执行的代码)
         *                  Thread类用于描述线程。Thread类定义了一个功能，用于存储线程要运行的代码，该存储功能就是run方法。
         *                  c.创建子类对象(实际上就创建了一个新的线程)
         *                  d.开启线程(调用start方法)   1.启动当前线程    2.调用当前线程的run()
         *
         *          扩展1:
         *             	获取线程名字:
         *             		如果当前线程继承Thread,那么我们可以直接调用getName()获取线程的名字
         *                     如果是主线程,我们调用Thread.currentThread().getName()获取线程的名字[通用方法]
         *                 设置线程名字:
         *             		我们可以获取对象后调用setName方法
         *                     通过构造方法,在创建线程时指定线程名字,但是构造方法我们要自己添加,因为父类的构造子类无法继承
         *                     public class MyThread extends Thread {
         *                         //构造方法子类无法继承
         *                         public MyThread(){}
         *                         public MyThread(String name){
         *                             super(name);
         *                         }
         *                     }
         *
         *
         *      5.创建新的线程方式二_实现方式
         *            API描述:
         * 	                创建线程的第二种方式:
         * 		                声明实现 Runnable 接口的类。
         *                      该类然后实现 run 方法。
         *                      然后可以分配该类的实例，
         *                      在创建 Thread 时作为一个参数来传递并启动
         *
         *            翻译步骤:
         *              	a.创建一个实现类实现Runnable接口
         *                  b.重写run方法(写需要执行的任务代码)
         *                      Thread类用于描述线程。Thread类定义了一个功能，用于存储线程要运行的代码，该存储功能就是run方法。
         *                  c.创建这个实现类对象(这个对象我们称为任务对象)
         *                  d.创建Thread对象时把任务对象作为参数传入
         *                  主要原因当前线程的run里边调用了Runnable类型的target的run(),target就是mThread
         *                  e.启动这个Thread对象
         *
         *      6.两种方法区别：
         *              1.开发中优先选择:实现Runnable接口的方法
         *                  原因:1.实现的方式没有类的单继承的局限性
         *                      2.实现的方式更适合来处理多个线程有共享数据的情况
         *              2.联系:
         *                  Thread类本身也是实现了Runnbale接口
         *                  两种方式都需要重写run(),将线程要执行的逻辑声明在run()中
         *
         * 		        (1)实现Runnable接口避免了单继承的局限性
         * 		        (2)继承Thread类线程代码存放在Thread子类的run方法中
         * 		            实现Runnable接口线程代码存放在接口的子类的run方法中；
         * 		             在定义线程时，建议使用实现Runnable接口，因为几乎所有多线程都可以使用这种方式实现
         *
         *--------------------------------------------------------------------------------------------------
         *
         *  高并发及线程安全
         *          1.高并发及线程安全
         *                  高并发:是指在某个时间点上，有大量的用户(线程)同时访问同一资源。
         *                  例如:天猫的双11购物 节、12306的在线购票在某个时间点上，都会面临大量用户同时抢购同一件商品/车票的情况。
         *
         *         2.线程安全:在某个时间点上，当大量用户(线程)访问同一资源时，由于多线程运行机制的原因，
         *                  可能会导致被访问的资源出现"数据污染"的问题。
         *
         *         3.多线程的运行机制
         *                  当一个线程启动后，JVM会为其分配一个独立的"线程栈区"，这个线程会在这个独立的栈区中运行。
         *                  多个线程在各自栈区中独立、无序的运行，当访问一些代码，或者同一个变量时，就可能会产生一些问题
         *
         *         4.出现了线程安全问题
         *              1.多线程安全性问题-可见性
         *                      多个线程拥有独立的栈,但是堆是共享的
         *                      我们一般称为独立的栈是线程的工作内存,共享的堆一般称为主内存
         *                      结论: 成员变量和共享变量保存主内存的,局部变量保存到工作内存中的
         *                      自己的话:
         *                      两个线程拿到一个共享变量的副本,其中一个线程对变量的值进行修改,
         *                      另一个线程如果没有腾出时间更新就不会获得修改后的变量值
         *
         *              2.多线程安全性问题-有序性
         *                      有序性:编译过程中可能对代码的执行顺序重排,单线程不影响结果,多线程由于线程独立,
         *                      所以在不同的执行顺序下会产生不同的结果
         *
         *              3.多线程安全性问题-原子性
         *                  原子性:两个线程同时对一个共享变量进行操作,会因为抢占cpu导致数据更新失败,而最终的值不如预期
         *
         *--------------------------------------------------------------------------------------------------
         *  补充:
         *      线程的分类
         *          Java中的线程分为两类:一种是守护线程,一种是用户线程
         *          1.它们在几乎每个方面都是相同的,唯一的区别是判断JVM何时离开
         *          2.守护线程是用来服务用户线程的,通过在start()方法前调用
         *              Thread.setDaemon(true) 可以把一个用户线程变成一个守护线程
         *          3.Java垃圾回收就是一个典型的守护线程
         *          4.若JVM中都是守护线程,当前JVM退出
         *
         *      JDK5.0 新增线程创建方式
         *          1.新增方式一:实现Callable接口
         *              1.与使用Runnable相比,Callable功能更强大一些
         *                  相比run()方法,可以有返回值
         *                  方法可以抛出异常
         *                  支持泛型的返回值
         *                  需要借助FutureTask类,比如获取返回结果
         *
         *          2.新增方式二:使用线程池
         *
         *
         *
         */
    }
}
