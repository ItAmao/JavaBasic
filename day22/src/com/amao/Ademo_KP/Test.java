package com.amao.Ademo_KP;


/**
 *  @Author : ItAmao
 *  @Date   : 2020/6/30 08:06
 */

public class Test {
    /**
     *  Properties类
     *      1.概述:
     *          Properties是一个集合,是HashTable的子类,
     *              Properties类表示一组持久的属性。 Properties可以保存到流中或从流中加载。
     *              属性列表中的每个键及其对应的值都是一个字符串。读取诺文件时需要使用这个类
     *              什么是集? 它是一个集合
     *              什么是属性集:其他就是键值对,本质就是一个Map集合
     *              什么是持久?  Properties类具有和硬盘交互的方法
     *
     *      2.构造方法
     *          public Properties(): //创建一个空属性的集合
     *
     *      3.成员方法
     *          public String setProperty(String key,String value):添加/修改属性,类似于map的put方法
     *          public String getProperty(String key): 根据属性名获取属性值:类似于map的get方法
     *          public Set<String>  stringPropertyNames():获取集合中所有的属性名,类似于map的keySet
     *
     *      4.与流相关的方法
     *          持久相关的方法,就是和流相关的方法
     *          public void store(OutputStream/Writer out,String 注释内容):
     *          public void load(InputStream/Reader in)
     *
     *----------------------------------------------------------------------------------------------------
     *  ResourceBundle
     *      1.ResourceBundle类的介绍
     *          ResourceBundle这个一个抽象类,
     *              其子类PropertyResourceBundle可以用于读取.Properties后缀的文件
     *          PropertyResourceBundle可以直接读取src目录下的.properties文件,并且我们读取文件时,只需要写文件名,不需要写文件后缀名
     *
     *      2.作用:
     *          这个类的作用就是读取资源属性文件（properties）的
     *
     *----------------------------------------------------------------------------------------------------
     *  缓冲流
     *      1.缓冲流的介绍
     *          缓冲流也称高效流,对普通流的性能进行了加强(方法和普通流基本上没什么区别)
     *
     *      2.缓冲流的分类
     *          字节输出流:OutputStream:---> BufferedOutputStream 缓冲字节输出流
     *          字节输入流:InputStream:----> BufferedInputStream 缓冲字节输入流
     *          字符输出流:Writer ---->  BufferedWriter 缓冲字符输出流
     *          字符输入流:Reader ----> BufferedReader 换成字符输入流
     *
     *      3.字节缓冲流的的介绍和使用
     *          a.字节缓冲流的构造
     *              public BufferedOutputStream(OutputSteam out) //创建缓冲流需要传入普通流
     *              public BufferedInputStream(InputStream in); //创建缓冲流需要传入普通流
     *
     *      4.字符缓冲流的介绍和使用
     *          a.字符缓冲流的构造
     *              public BufferedWriter(Writer w): 创建字符缓冲流需要传入普通的字符流
     *              public BufferedReader(Reader r): 创建字符缓冲流需要传入普通的字符流
     *          b.字符缓冲流2个特有的方法
     *              public void newLine(): 写入一个换行符
     *              BufferedReader相比于FileReader有一个特有方法:
     *                  public String readLine();
     *
     * ----------------------------------------------------------------------------------------------------
     *  转换流:
     *      1.编码和解码                                 128    64    32    16   8   4  2  1
     *          编码:把字符 --> 对应的码值 ---> 比如 a----> 0       1    1     0    0   0  0  1
     *          解码:把码值 --> 对应的字符 ---> 比如:0110 0010 ---> b
     *
     *      2.字符编码
     *          什么是字符编码:一套规则,字符和其码值之间对应的规则
     *
     *      3.字符集
     *          什么是字符集:是指一个系统上支持的所有字符的集合,包括文本,文字,标点符号,图形符号,数字等
     *          常见的字符集和常见的字符集编码有哪些?
     *              a."ASCII字符集": 包括英文字母,符号,阿拉伯数字等
     *                  其对应的字符编码,"ASCII编码",在这个编码中所有的字符是占"一个字节"
     *              b."GBxxxx"字符集
     *                  GB2312字符集: 包括常见简体汉字,大概7000多个
     *                  GBK字符集:包含常见的汉字(简体+繁体+日韩文字),大概20000多个
     *                  GBK18030字符集(最新字符集):包含各种汉字,少数民族的文字,大概70000多个
     *                  其对应的字符编码,"GBK编码",在这个编码中一个中文占"两个字节"
     *              c."Unicode"字符集(统一字符集)
     *                  其对应的字符编码,UTF-8,UTF-16,UTF-32,...
     *                  在"UTF-8"中一个中文占"三个字节"
     *              d.ISO-8859-1字符集(拉丁字符集,西欧国家的字符集)
     *                  我们以后的服务器Tomcat7以前默认使用的就是ISO-8859-1
     *
     *      4.使用转换流InputStreamReader解决读取中文的问题
     *          1.InputStreamReader转换输入流
     *              作用:可以在读取文件时,指定编码
     *          2.构造方法:
     *              public InputStreamReader(InputStream in,String charsetName):创建一个转换输入流,
     *              底层需要一个普通的字节流,charsetName表示指定的字符编码名字
     *              public InputStreamReader(InputStream in);创建一个转换输入流,底层需要一个普通的字节流
     *              编码格式默认idea的UTF-8
     *
     *     5.使用转换流OutputStreamWriter写不同编码的中文
     *          1.OutputStreamWriter 转换输出流
     *               作用:可以在写文件,指定编码!!
     *          2.构造方法
     *              public OutputStreamWriter(OutputStream out,String charsetName);
     *              //创建转换输出流,底层需要一个字节输出流,参数charsetName表示指定的编码名字
     *              public OutputStreamWriter(OutputStream out);
     *              //创建转换输出流,底层需要一个字节输出流,默认使用idea的默认字符编码!
     *
     * ----------------------------------------------------------------------------------------------------
     *  序列化流
     *      1.什么是序列化流
     *          序列化流,就是操作对象的流
     *
     *      2.分类:
     *          序列化流:对象的输出流,写对象
     *          反序列化流:对象的输入流,读对象
     *
     *      3.概述:
     *          序列化:把对象从内存输出到硬盘中叫做持久保存
     *          反序列化:把对象从硬盘中输入到内存恢复对象形式
     *
     *      2.ObjectOutputStream类
     *          a.介绍和使用
     *              对象的字节输出流,写对象
     *              序列化流(对象输出流)
     *              构造方法:
     *          b.构造方法
     *              public ObjectOutputStream(OutputStream out)
     *          c.序列化操作的前提
     *              被序列化的类必须实现java.io.Serializable接口,开启序列化功能
     *              跟接口没有任何的方法,这种接口我们称为标记接口
     *
     *      3.作用:
     *          作用是用来保存对象内存,不是用来保存文本,
     *
     *      4.对象操作流的小知识
     *          transient关键字
     *              表示瞬态:瞬态可以修饰成员变量,被修饰的变量不会被序列化
     *          serialVersionUID问题
     *              每次操作类,类都会自动的分配一个序列号,如果输出和输入之间序列号发生了改变,那么程序就会报错
     *          序列化多个对象
     *              readObject这个方法如果读不到对象,就直接抛出EOFException 导致我们不能循环读取
     *              所以无法保存多个对象,所以我们以后用这个流只保存一个对象
     *              如果想要保存多个对象,我们可以使用集合来完成
     *
     *    5.反序列化操作的两种异常演示
     *      a.ClassNotFoundException 找不到类异常
     *          原因:序列化之后,将被序列化的类删除了,然后进行反序列化即出现这个异常
     *      b.InvalidClassException 无效类异常
     *          原因:序列化之后,将被序列化的类进行修改,然后进行反序列化即可出现这种异常
     *      c.  扩展:反序列化流如何判断类是否有效呢???
     *           通过serialVersionUID(序列化版本号)来判断,而serialVersionUID通过类的成员内容计算而来的
     *          也就是只要类的内容没变,那么版本号也不会改变,只要内容改变那么版本号也会跟着改变!
     *
     *----------------------------------------------------------------------------------------------------
     *  打印流
     *      1.概述:
     *          PrintStream:打印流,可以方便的输出各种数据类型的数据
     *          特点:
     *              a.打印流永远不会抛出IOException
     *              b.啥都可以打印,所见即所得
     *          打印流就是输出,(我们输出语句也就是一个流对象)
     *
     *      2.构造方法
     *          public void printStream(String path):使用指定的文件名创建新的打印流，无需自动换行。
     *          public PrintStream(File file);使用指定的文件创建一个新的打印流，而不需要自动换行。
     *          public PrintStream(OutputStream out); 创建一个新的打印流。
     *
     *      3.成员方法
     *          public void print(各种数据类型均可);//打印数据,但是不带换行
     *      	public void println(各种数据类型均可);//打印数据,末尾自动带换行
     *
     *      4.打印流的流向(了解)
     *
     *----------------------------------------------------------------------------------------------------
     *  装饰设计模式
     *      1.概述
     *          在不改变原来类,也不使用继承的基础上增强类的某个功能
     *          一个类在不使用继承的情况下,可以使用装饰设计模式来对类中的方法进行增强
     *          (装饰模式在)
     *          前提:要增强的类必须实现接口
     *
     *      2.装饰模式的写法
     *          1.装饰类和被装饰类必须实现相同的接口
     *          2.在装饰类中必须传入被装饰类的引用
     *          3.在装饰类中对需要扩展的方法进行扩展
     *          4.在装饰类中对不需要扩展的方法调用被装饰类中的同名方法
     *
     *      3.作用:
     *          缓冲流的内部用的都是装饰设计模式
     *          开发的原则:高内聚,低耦合,
     *          高内聚:自己独立解决问题的能力
     *          低耦合:类和类之间的互相依赖
     *          继承的缺点:增加的类和类的耦合
     *
     *      4.
     *
     *----------------------------------------------------------------------------------------------------
     *  commons-io包
     *      1.概述
     *          commons-io:是Apache基金组织提供的一个开源jar包
     *          不是jdk的内容,不在JDk里的内库,我们都称为第三方工具
     *
     *
     *      2.使用方式:
     *
     *
     *----------------------------------------------------------------------------------------------------
     *
     *
     *
     *
     */
    public static void main(String[] args) {
    }
}
